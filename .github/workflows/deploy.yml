name: Deploy to Production

on:
  push:
    branches: [main, devOps] # Added devOps branch
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_FRONTEND: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com/myblog/frontend
  ECR_BACKEND: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com/myblog/backend

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # --- ADDED STEP ---
      # This step ensures the AWS CLI is installed and available.
      # It handles the case where it might already be present.
      - name: Ensure AWS CLI is installed and in PATH
        run: |
          if ! command -v aws &> /dev/null; then
            echo "AWS CLI not found, installing..."
            curl -sL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip awscliv2.zip
            sudo ./aws/install
          else
            echo "AWS CLI is already installed."
            # If already installed, ensure the path is correct for this step's shell
            export PATH="/usr/local/aws-cli/v2/current/bin:$PATH"
          fi
          aws --version # Verify installation and availability in this step
      # --- END OF ADDED STEP ---
      - name: Build and push backend image
        run: |
          docker build -f apps/backend/Dockerfile -t $ECR_BACKEND:$GITHUB_SHA .
          docker tag $ECR_BACKEND:$GITHUB_SHA $ECR_BACKEND:latest
          docker push $ECR_BACKEND:$GITHUB_SHA
          docker push $ECR_BACKEND:latest

      - name: Build and push frontend image
        run: |
          docker build -f apps/frontend/Dockerfile \
            --build-arg NEXT_PUBLIC_BACKEND_BASE_URL=https://${{ secrets.DOMAIN_NAME }} \
            --build-arg NEXT_PUBLIC_GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }} \
            --build-arg NEXT_PUBLIC_TINYMCE_API_KEY=${{ secrets.TINYMCE_API_KEY }} \
            -t $ECR_FRONTEND:$GITHUB_SHA .
          docker tag $ECR_FRONTEND:$GITHUB_SHA $ECR_FRONTEND:latest
          docker push $ECR_FRONTEND:$GITHUB_SHA
          docker push $ECR_FRONTEND:latest

      - name: Deploy to EC2 via SSM
        run: |
          echo "Verifying AWS CLI availability in deployment step..."
          command -v aws || { echo "ERROR: aws command not found in deployment step!"; exit 1; }
          aws --version
          echo "AWS CLI verified. Proceeding with deployment."

          # Get instance ID from EC2 public IP
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=ip-address,Values=${{ secrets.EC2_HOST }}" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text \
            --region ap-southeast-1)

          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
              echo "Error: Could not find a running EC2 instance with IP ${{ secrets.EC2_HOST }}"
              exit 1
          fi

          echo "Found EC2 instance: $INSTANCE_ID"

          # Use simple inline SSM commands
          ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}" # Note: This might be empty if login failed, but login usually doesn't fail silently
          if [ -z "$ECR_REGISTRY" ]; then
              # Fallback to constructing registry from secrets if step output is empty
              ECR_REGISTRY="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          fi
          ECR_FRONTEND="${{ env.ECR_FRONTEND }}" # Use the environment variable
          ECR_BACKEND="${{ env.ECR_BACKEND }}"   # Use the environment variable

          # Store ECR registry URL for the deployment script
          aws ssm put-parameter \
            --name "/myblog/deploy/ECR_REGISTRY" \
            --value "$ECR_REGISTRY" \
            --type "String" \
            --overwrite \
            --region us-east-1

          aws ssm put-parameter \
            --name "/myblog/deploy/MONGODB_URI" \
            --value "${{ secrets.MONGODB_URI }}" \
            --type "SecureString" \
            --overwrite \
            --region us-east-1

          aws ssm put-parameter \
            --name "/myblog/deploy/JWT_SECRET" \
            --value "${{ secrets.JWT_SECRET }}" \
            --type "SecureString" \
            --overwrite \
            --region us-east-1

          aws ssm put-parameter \
            --name "/myblog/deploy/GOOGLE_CLIENT_ID" \
            --value "${{ secrets.GOOGLE_CLIENT_ID }}" \
            --type "String" \
            --overwrite \
            --region us-east-1

          aws ssm put-parameter \
            --name "/myblog/deploy/GOOGLE_CLIENT_SECRET" \
            --value "${{ secrets.GOOGLE_CLIENT_SECRET }}" \
            --type "SecureString" \
            --overwrite \
            --region us-east-1

          aws ssm put-parameter \
            --name "/myblog/deploy/ADMIN_SETUP_TOKEN" \
            --value "${{ secrets.ADMIN_SETUP_TOKEN }}" \
            --type "SecureString" \
            --overwrite \
            --region us-east-1

          aws ssm put-parameter \
            --name "/myblog/deploy/NEXTAUTH_SECRET" \
            --value "${{ secrets.NEXTAUTH_SECRET }}" \
            --type "SecureString" \
            --overwrite \
            --region us-east-1

          aws ssm put-parameter \
            --name "/myblog/deploy/TINYMCE_API_KEY" \
            --value "${{ secrets.TINYMCE_API_KEY }}" \
            --type "String" \
            --overwrite \
            --region us-east-1

          # Create deployment script with AWS_ACCOUNT_ID embedded
          AWS_ACCOUNT_ID="${{ secrets.AWS_ACCOUNT_ID }}"
          cat > deploy.sh << EOF
          #!/bin/bash
          set -e

          echo "Starting deployment..."

          # Install dependencies if needed
          if ! command -v aws &> /dev/null; then
            echo "Installing AWS CLI..."
            apt-get update -y
            apt-get install -y unzip curl
            curl -sL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip -q awscliv2.zip
            ./aws/install --update
            rm -rf aws awscliv2.zip
          fi

          if ! command -v docker-compose &> /dev/null; then
            echo "Installing Docker Compose..."
            curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-\$(uname -s)-\$(uname -m)" -o /usr/local/bin/docker-compose
            chmod +x /usr/local/bin/docker-compose
          fi

          if ! command -v git &> /dev/null; then
            echo "Installing Git..."
            apt-get install -y git
          fi

          # Change to home directory
          cd /home/ubuntu

          # Clone/update repository
          echo "Cloning repository..."
          rm -rf MyBlog
          git clone https://github.com/BlockAce01/MyBlog.git MyBlog
          cd MyBlog

          # Retrieve SSM parameters and create environment file
          echo "Retrieving SSM parameters and creating environment file..."
          AWS_ACCOUNT_ID='${AWS_ACCOUNT_ID}'
          MONGODB_URI=\$(aws ssm get-parameter --name /myblog/deploy/MONGODB_URI --with-decryption --query Parameter.Value --output text --region us-east-1 2>/dev/null || echo "mongodb://localhost:27017/myblog")
          JWT_SECRET=\$(aws ssm get-parameter --name /myblog/deploy/JWT_SECRET --with-decryption --query Parameter.Value --output text --region us-east-1 2>/dev/null || echo "fallback-jwt-secret")
          GOOGLE_CLIENT_ID=\$(aws ssm get-parameter --name /myblog/deploy/GOOGLE_CLIENT_ID --query Parameter.Value --output text --region us-east-1 2>/dev/null || echo "fallback-google-client-id")
          GOOGLE_CLIENT_SECRET=\$(aws ssm get-parameter --name /myblog/deploy/GOOGLE_CLIENT_SECRET --with-decryption --query Parameter.Value --output text --region us-east-1 2>/dev/null || echo "fallback-google-client-secret")
          ADMIN_SETUP_TOKEN=\$(aws ssm get-parameter --name /myblog/deploy/ADMIN_SETUP_TOKEN --with-decryption --query Parameter.Value --output text --region us-east-1 2>/dev/null || echo "fallback-admin-token")
          NEXTAUTH_SECRET=\$(aws ssm get-parameter --name /myblog/deploy/NEXTAUTH_SECRET --with-decryption --query Parameter.Value --output text --region us-east-1 2>/dev/null || echo "fallback-nextauth-secret")
          NEXT_PUBLIC_TINYMCE_API_KEY=\$(aws ssm get-parameter --name /myblog/deploy/TINYMCE_API_KEY --query Parameter.Value --output text --region us-east-1 2>/dev/null || echo "fallback-tinymce-key")

          cat > .env << ENV_EOF
          AWS_ACCOUNT_ID=\${AWS_ACCOUNT_ID}
          MONGODB_URI=\${MONGODB_URI}
          JWT_SECRET=\${JWT_SECRET}
          GOOGLE_CLIENT_ID=\${GOOGLE_CLIENT_ID}
          GOOGLE_CLIENT_SECRET=\${GOOGLE_CLIENT_SECRET}
          ADMIN_SETUP_TOKEN=\${ADMIN_SETUP_TOKEN}
          NEXTAUTH_SECRET=\${NEXTAUTH_SECRET}
          NEXT_PUBLIC_TINYMCE_API_KEY=\${NEXT_PUBLIC_TINYMCE_API_KEY}
          ENV_EOF

          echo "Environment file created successfully"

          # Deploy containers
          echo "Deploying containers..."
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin \${AWS_ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com

          docker pull \${AWS_ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com/myblog/frontend:latest
          docker pull \${AWS_ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com/myblog/backend:latest

          docker-compose -f docker-compose.prod.yml down || true
          docker-compose -f docker-compose.prod.yml up -d

          echo "Waiting for services..."
          sleep 30

          docker ps

          echo "Running health checks..."
          if curl -f http://localhost:3000/api/health; then
            echo "âœ… Frontend OK"
          else
            echo "âŒ Frontend failed"
            exit 1
          fi

          if curl -f http://localhost:3003/health; then
            echo "âœ… Backend OK"
          else
            echo "âŒ Backend failed"
            exit 1
          fi

          echo "ðŸŽ‰ Deployment completed!"
          EOF

          chmod +x deploy.sh

          # Send SSM command to execute the deployment script
          COMMAND_ID=\$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["chmod +x /home/ubuntu/deploy.sh", "/home/ubuntu/deploy.sh"]' \
            --output text \
            --query 'Command.CommandId' \
            --region ap-southeast-1)

          if [ -z "$COMMAND_ID" ]; then
              echo "Error: Failed to send SSM command."
              exit 1
          fi

          echo "SSM Command sent. Command ID: $COMMAND_ID"

          # Wait for command to complete (increased timeout)
          echo "Waiting for deployment to complete (this may take several minutes)..."
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --region ap-southeast-1 \
            --cli-read-timeout 600 \
            --cli-connect-timeout 60

          # Get command result
          RESULT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --region ap-southeast-1 \
            --query 'Status' \
            --output text)

          echo "Deployment status: $RESULT"

          # Get command output for debugging
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --region ap-southeast-1 \
            --query 'StandardOutputContent' \
            --output text

          if [ "$RESULT" = "Success" ]; then
            echo "âœ… Deployment completed successfully!"
            echo "ðŸŒ Application should be accessible at: https://${{ secrets.DOMAIN_NAME }}"
            echo "ðŸ”§ Direct access via IP: http://${{ secrets.EC2_HOST }}"
          else
            echo "âŒ Deployment failed with status: $RESULT"
            echo "Error details:"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --region ap-southeast-1 \
              --query 'StandardErrorContent' \
              --output text
            exit 1
          fi
