name: Deploy to Production

on:
  push:
    branches: [main, devOps] # Added devOps branch
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_FRONTEND: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com/myblog/frontend
  ECR_BACKEND: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com/myblog/backend

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push backend image
        run: |
          docker build -f apps/backend/Dockerfile -t $ECR_BACKEND:$GITHUB_SHA .
          docker tag $ECR_BACKEND:$GITHUB_SHA $ECR_BACKEND:latest
          docker push $ECR_BACKEND:$GITHUB_SHA
          docker push $ECR_BACKEND:latest

      - name: Build and push frontend image
        run: |
          docker build -f apps/frontend/Dockerfile \
            --build-arg NEXT_PUBLIC_BACKEND_BASE_URL=https://${{ secrets.DOMAIN_NAME }} \
            --build-arg NEXT_PUBLIC_GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }} \
            --build-arg NEXT_PUBLIC_TINYMCE_API_KEY=${{ secrets.TINYMCE_API_KEY }} \
            -t $ECR_FRONTEND:$GITHUB_SHA .
          docker tag $ECR_FRONTEND:$GITHUB_SHA $ECR_FRONTEND:latest
          docker push $ECR_FRONTEND:$GITHUB_SHA
          docker push $ECR_FRONTEND:latest

      - name: Deploy to EC2 via SSM
        run: |
          # Get instance ID from EC2 public IP
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=ip-address,Values=${{ secrets.EC2_HOST }}" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text \
            --region ap-southeast-1)

          echo "Found EC2 instance: $INSTANCE_ID"

          # Create deployment script
          cat > deploy_script.sh << 'EOF'
          #!/bin/bash
          set -e
          echo "Starting deployment..."

          # Install prerequisites
          which aws || (
            echo "Installing AWS CLI..."
            apt-get update -y
            apt-get install -y unzip curl
            curl -s "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip awscliv2.zip
            ./aws/install -i /usr/local/aws-cli -b /usr/local/bin
            rm -rf aws awscliv2.zip
          )

          which docker-compose || (
            echo "Installing Docker Compose..."
            curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            chmod +x /usr/local/bin/docker-compose
          )

          which git || apt-get install -y git

          # Navigate to ubuntu home directory
          cd /home/ubuntu

          # Clean up and clone repository (FIXED: correct repo name)
          echo "Cloning repository..."
          rm -rf MyBlog
          git clone https://github.com/BlockAce01/MyBlog.git MyBlog
          cd MyBlog

          # Login to ECR
          echo "Logging into ECR..."
          /usr/local/bin/aws ecr get-login-password --region us-east-1 | \
            docker login --username AWS --password-stdin $ECR_REGISTRY

          # Pull latest images
          echo "Pulling latest images..."
          docker pull $ECR_FRONTEND:latest
          docker pull $ECR_BACKEND:latest

          # Create .env file for production (FIXED: environment persistence)
          echo "Creating production environment file..."
          cat > .env << 'ENV_EOF'
          AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID
          MONGODB_URI=$MONGODB_URI
          JWT_SECRET=$JWT_SECRET
          GOOGLE_CLIENT_ID=$GOOGLE_CLIENT_ID
          GOOGLE_CLIENT_SECRET=$GOOGLE_CLIENT_SECRET
          ADMIN_SETUP_TOKEN=$ADMIN_SETUP_TOKEN
          NEXTAUTH_SECRET=$NEXTAUTH_SECRET
          NEXT_PUBLIC_TINYMCE_API_KEY=$NEXT_PUBLIC_TINYMCE_API_KEY
          ENV_EOF

          # Stop existing containers
          echo "Stopping existing containers..."
          docker-compose -f docker-compose.prod.yml down || true

          # Start new containers
          echo "Starting new containers..."
          docker-compose -f docker-compose.prod.yml up -d

          # Wait for services to be ready
          echo "Waiting for services to be ready..."
          sleep 30

          # Verify deployment
          echo "Verifying deployment..."
          docker ps

          # Health checks
          echo "Performing health checks..."
          curl -f http://localhost:3000/api/health || {
            echo "Frontend health check failed"
            docker-compose -f docker-compose.prod.yml logs frontend
            exit 1
          }

          curl -f http://localhost:3003/health || {
            echo "Backend health check failed"
            docker-compose -f docker-compose.prod.yml logs backend
            exit 1
          }

          echo "âœ… Deployment completed successfully!"
          EOF

          # Create deployment script with embedded environment variables
          cat > deploy_script_with_env.sh << EOF
          #!/bin/bash
          set -e
          export ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          export ECR_FRONTEND=$ECR_FRONTEND
          export ECR_BACKEND=$ECR_BACKEND
          export AWS_ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID }}
          export MONGODB_URI='${{ secrets.MONGODB_URI }}'
          export JWT_SECRET='${{ secrets.JWT_SECRET }}'
          export GOOGLE_CLIENT_ID='${{ secrets.GOOGLE_CLIENT_ID }}'
          export GOOGLE_CLIENT_SECRET='${{ secrets.GOOGLE_CLIENT_SECRET }}'
          export ADMIN_SETUP_TOKEN='${{ secrets.ADMIN_SETUP_TOKEN }}'
          export NEXTAUTH_SECRET='${{ secrets.NEXTAUTH_SECRET }}'
          export NEXT_PUBLIC_TINYMCE_API_KEY='${{ secrets.TINYMCE_API_KEY }}'

          echo "Starting deployment..."

          # Install prerequisites
          which aws || (
            echo "Installing AWS CLI..."
            apt-get update -y
            apt-get install -y unzip curl
            curl -s "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip awscliv2.zip
            ./aws/install -i /usr/local/aws-cli -b /usr/local/bin
            rm -rf aws awscliv2.zip
          )

          which docker-compose || (
            echo "Installing Docker Compose..."
            curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-\$(uname -s)-\$(uname -m)" -o /usr/local/bin/docker-compose
            chmod +x /usr/local/bin/docker-compose
          )

          which git || apt-get install -y git

          # Navigate to ubuntu home directory
          cd /home/ubuntu

          # Clean up and clone repository
          echo "Cloning repository..."
          rm -rf MyBlog
          git clone https://github.com/BlockAce01/MyBlog.git MyBlog
          cd MyBlog

          # Login to ECR
          echo "Logging into ECR..."
          /usr/local/bin/aws ecr get-login-password --region us-east-1 | \\
            docker login --username AWS --password-stdin \$ECR_REGISTRY

          # Pull latest images
          echo "Pulling latest images..."
          docker pull \$ECR_FRONTEND:latest
          docker pull \$ECR_BACKEND:latest

          # Create .env file for production
          echo "Creating production environment file..."
          cat > .env << 'ENV_EOF'
          AWS_ACCOUNT_ID=\$AWS_ACCOUNT_ID
          MONGODB_URI=\$MONGODB_URI
          JWT_SECRET=\$JWT_SECRET
          GOOGLE_CLIENT_ID=\$GOOGLE_CLIENT_ID
          GOOGLE_CLIENT_SECRET=\$GOOGLE_CLIENT_SECRET
          ADMIN_SETUP_TOKEN=\$ADMIN_SETUP_TOKEN
          NEXTAUTH_SECRET=\$NEXTAUTH_SECRET
          NEXT_PUBLIC_TINYMCE_API_KEY=\$NEXT_PUBLIC_TINYMCE_API_KEY
          ENV_EOF

          # Stop existing containers
          echo "Stopping existing containers..."
          docker-compose -f docker-compose.prod.yml down || true

          # Start new containers
          echo "Starting new containers..."
          docker-compose -f docker-compose.prod.yml up -d

          # Wait for services to be ready
          echo "Waiting for services to be ready..."
          sleep 30

          # Verify deployment
          echo "Verifying deployment..."
          docker ps

          # Health checks
          echo "Performing health checks..."
          curl -f http://localhost:3000 || {
            echo "Frontend health check failed"
            docker-compose -f docker-compose.prod.yml logs frontend
            exit 1
          }

          curl -f http://localhost:3003/health || {
            echo "Backend health check failed"
            docker-compose -f docker-compose.prod.yml logs backend
            exit 1
          }

          echo "âœ… Deployment completed successfully!"
          EOF

          # Send SSM command
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"$(cat deploy_script_with_env.sh)\"]" \
            --output text \
            --query 'Command.CommandId' \
            --region ap-southeast-1)

          echo "SSM Command sent. Command ID: $COMMAND_ID"

          # Wait for command to complete (increased timeout)
          echo "Waiting for deployment to complete (this may take several minutes)..."
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --region ap-southeast-1 \
            --cli-read-timeout 600 \
            --cli-connect-timeout 60

          # Get command result
          RESULT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --region ap-southeast-1 \
            --query 'Status' \
            --output text)

          echo "Deployment status: $RESULT"

          # Get command output for debugging
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --region ap-southeast-1 \
            --query 'StandardOutputContent' \
            --output text

          if [ "$RESULT" = "Success" ]; then
            echo "âœ… Deployment completed successfully!"
            echo "ðŸŒ Application should be accessible at: https://${{ secrets.DOMAIN_NAME }}"
            echo "ðŸ”§ Direct access via IP: http://${{ secrets.EC2_HOST }}"
          else
            echo "âŒ Deployment failed with status: $RESULT"
            echo "Error details:"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --region ap-southeast-1 \
              --query 'StandardErrorContent' \
              --output text
            exit 1
          fi
